"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricFactory = exports.DefaultMetricPeriod = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const aws_cloudwatch_1 = require("aws-cdk-lib/aws-cloudwatch");
const AnomalyDetectionMathExpression_1 = require("./AnomalyDetectionMathExpression");
const MetricStatistic_1 = require("./MetricStatistic");
const RateComputationMethod_1 = require("./RateComputationMethod");
/**
 * The most common default metric period used at Amazon is currently 5 minutes.
 */
exports.DefaultMetricPeriod = aws_cdk_lib_1.Duration.minutes(5);
class MetricFactory {
    // TODO: make scope required and first. This is for backwards compatability for now.
    constructor(props, scope) {
        this.globalDefaults = props?.globalDefaults ?? {};
        this.scope = scope;
    }
    /**
     * Factory method that creates a metric. The metric properties will already be updated to comply with the global defaults.
     *
     * @param metricName metric name
     * @param statistic aggregation statistic to use
     * @param label metric label; if undefined, metric name is used by CloudWatch
     * @param dimensionsMap additional dimensions to be added
     * @param color metric color; if undefined, uses a CloudWatch provided color (preferred)
     * @param namespace specify a custom namespace; if undefined, uses the global default
     * @param period specify a custom period; if undefined, uses the global default
     * @param region specify a custom region; if undefined, uses the global default
     * @param account specify a custom account; if undefined, uses the global default
     */
    createMetric(metricName, statistic, label, dimensionsMap, color, namespace, period, region, account) {
        return new aws_cloudwatch_1.Metric({
            statistic,
            metricName,
            label,
            color,
            dimensionsMap: dimensionsMap
                ? this.removeUndefinedEntries(dimensionsMap)
                : undefined,
            namespace: this.getNamespaceWithFallback(namespace),
            period: period ?? this.globalDefaults.period ?? exports.DefaultMetricPeriod,
            region: this.resolveRegion(region ?? this.globalDefaults.region),
            account: this.resolveAccount(account ?? this.globalDefaults.account),
        });
    }
    /**
     * Factory method that creates a metric math expression. The metric properties will already be updated to comply with the global defaults.
     *
     * @param expression CloudWatch metric math expression (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html)
     * @param usingMetrics map of metrics, where keys are expression IDs (used in the expression) and values are metrics
     * @param label metric label (required, as there is no reasonable default)
     * @param color metric color; if undefined, uses a CloudWatch provided color (preferred)
     * @param period specify a custom period; if undefined, uses the global default
     * @param region specify a custom region; if undefined, uses the global default
     * @param account specify a custom account; if undefined, uses the global default
     */
    createMetricMath(expression, usingMetrics, label, color, period, region, account) {
        return new aws_cloudwatch_1.MathExpression({
            label,
            color,
            expression,
            usingMetrics,
            period: period ?? this.globalDefaults.period ?? exports.DefaultMetricPeriod,
            searchRegion: this.resolveRegion(region ?? this.globalDefaults.region),
            searchAccount: this.resolveAccount(account ?? this.globalDefaults.account),
        });
    }
    /**
     * Factory method that creates a metric search query. The metric properties will already be updated to comply with the global defaults.
     * If you want to match "any value" of a specific dimension, please use `undefined` value representation in your consumer language.
     * (For example, `undefined as any as string` in TypeScript, due to JSII typing quirks.)
     *
     * @param query metric search query (the same as the search query prompt in CloudWatch AWS Console), it might also be empty
     * @param dimensionsMap dimensions, further narrowing the search results; use `undefined` if you want to represent "any value" (in TS: `undefined as any as string`)
     * @param statistic aggregation statistic to use
     * @param namespace specify a custom namespace; if undefined, uses the global default
     * @param label specify custom label for search metrics; default is " " as it cannot be empty string
     * @param period specify a custom period; if undefined, uses the global default
     * @param region specify a custom region; if undefined, uses the global default
     * @param account specify a custom account; if undefined, uses the global default
     */
    createMetricSearch(query, dimensionsMap, statistic, namespace, label, period, region, account) {
        const finalPeriod = period ?? this.globalDefaults.period ?? exports.DefaultMetricPeriod;
        const searchNamespace = this.getNamespaceWithFallback(namespace);
        const namespacePlusDimensionKeys = [
            searchNamespace,
            ...Object.keys(dimensionsMap),
        ].join(",");
        const metricSchema = `{${namespacePlusDimensionKeys}}`;
        const dimensionKeysAndValues = Object.entries(this.removeUndefinedEntries(dimensionsMap))
            .map(([key, value]) => `${key}="${value}"`)
            .join(" ");
        const expression = `SEARCH('${metricSchema} ${dimensionKeysAndValues} ${query}', '${statistic}', ${finalPeriod.toSeconds()})`;
        return new aws_cloudwatch_1.MathExpression({
            expression,
            // see https://github.com/aws/aws-cdk/issues/7237
            usingMetrics: {},
            // cannot be an empty string and undefined is no good either
            label: label ?? " ",
            period: finalPeriod,
            searchRegion: this.resolveRegion(region ?? this.globalDefaults.region),
            searchAccount: this.resolveAccount(account ?? this.globalDefaults.account),
        });
    }
    /**
     * Factory method that creates anomaly detection on a metric.
     * Anomaly occurs whenever a metric value falls outside of a precomputed range of predicted values.
     * The detection does not need any setup. The model will start learning automatically and should be ready in a few minutes.
     * Usually, the anomaly detection is paired with an alarm.
     * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Anomaly_Detection.html
     *
     * @param metric metric to detect anomaly detection of
     * @param stdev standard deviation, basically the tolerance / band thickness
     * @param label metric label (required, as there is no reasonable default)
     * @param color metric color; if undefined, uses a CloudWatch provided color (preferred)
     * @param expressionId expression ID of the metric; uses `m1` if undefined
     * @param period specify a custom period; if undefined, uses the global default
     * @param region specify a custom region; if undefined, uses the global default
     * @param account specify a custom account; if undefined, uses the global default
     */
    createMetricAnomalyDetection(metric, stdev, label, color, expressionId, period, region, account) {
        const finalExpressionId = expressionId ?? "m1";
        const usingMetrics = {};
        usingMetrics[finalExpressionId] = metric;
        return new AnomalyDetectionMathExpression_1.AnomalyDetectionMathExpression({
            label,
            color,
            usingMetrics,
            expression: `ANOMALY_DETECTION_BAND(${finalExpressionId},${stdev})`,
            period: period ?? this.globalDefaults.period ?? exports.DefaultMetricPeriod,
            searchRegion: this.resolveRegion(region ?? this.globalDefaults.region),
            searchAccount: this.resolveAccount(account ?? this.globalDefaults.account),
        });
    }
    /**
     * Adapts properties of a foreign metric (metric created outside of this metric factory) to comply with the global defaults.
     * Might modify namespace and metric period.
     *
     * @param metric metric to be adapted
     */
    adaptMetric(metric) {
        return metric.with({
            period: this.globalDefaults.period ?? exports.DefaultMetricPeriod,
        });
    }
    /**
     * Adapts properties of a foreign metric (metric created outside of this metric factory) to comply with the global defaults.
     * Might modify namespace. Preserves metric period.
     *
     * @param metric metric to be adapted
     */
    adaptMetricPreservingPeriod(metric) {
        return metric;
    }
    /**
     * Creates a metric math expression that multiplies the given metric by given coefficient.
     * Does nothing if the multiplier is one. Preserves the metric period.
     *
     * @param metric metric to multiply
     * @param multiplier multiplier (must be > 1)
     * @param label expression label
     * @param expressionId expression ID of the metric; uses `m1` if undefined
     */
    multiplyMetric(metric, multiplier, label, expressionId) {
        if (multiplier == 1) {
            return metric;
        }
        else if (multiplier < 1) {
            throw new Error("Multiplier must be greater than one.");
        }
        else {
            const finalExpressionId = expressionId ?? "m1";
            const usingMetrics = {};
            usingMetrics[finalExpressionId] = metric;
            return this.createMetricMath(`${finalExpressionId} * ${multiplier}`, usingMetrics, label, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
        }
    }
    /**
     * Creates a metric math expression that divides the given metric by given coefficient.
     * Does nothing if the divisor is one. Preserves the metric period.
     *
     * @param metric metric to multiply
     * @param divisor divisor (must be > 1)
     * @param label expression label
     * @param expressionId expression ID of the metric; uses `m1` if undefined
     */
    divideMetric(metric, divisor, label, expressionId) {
        if (divisor == 1) {
            return metric;
        }
        else if (divisor < 1) {
            throw new Error("Divisor must be greater than one.");
        }
        else {
            const finalExpressionId = expressionId ?? "m1";
            const usingMetrics = {};
            usingMetrics[finalExpressionId] = metric;
            return this.createMetricMath(`${finalExpressionId} / ${divisor}`, usingMetrics, label, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
        }
    }
    /**
     * Creates a metric math expression that computes a rate from a regular metric.
     * For example, it allows you to compute rate per second (TPS), per minute, or just an average of your transactions.
     *
     * @param metric metric to calculate the rate from
     * @param method rate computation method
     * @param addStatsToLabel add detailed statistics (min, max, average) to the label
     * @param expressionId expression ID of the metric; uses `m1` if undefined
     * @param fillWithZeroes if TRUE, the final metric will be zero-filled (0 on no data); false if undefined
     */
    toRate(metric, method, addStatsToLabel, expressionId, fillWithZeroes) {
        const finalExpressionId = expressionId ?? "m1";
        const labelPrefix = metric.label ?? "Rate";
        const statsInLabel = [];
        if (addStatsToLabel ?? false) {
            statsInLabel.push("min: ${MIN}");
            statsInLabel.push("max: ${MAX}");
            if (method !== RateComputationMethod_1.RateComputationMethod.AVERAGE) {
                // only add average if do not have it already
                statsInLabel.push("avg: ${AVG}");
            }
        }
        const finalExpressionIdZeroed = fillWithZeroes ?? false
            ? `FILL(${finalExpressionId},0)`
            : finalExpressionId;
        const labelAppendix = statsInLabel.length > 0 ? ` (${statsInLabel.join(", ")})` : "";
        switch (method) {
            case RateComputationMethod_1.RateComputationMethod.AVERAGE:
                const avgLabel = `${labelPrefix} (avg)${labelAppendix}`;
                const avgMetric = metric.with({
                    label: avgLabel,
                    statistic: MetricStatistic_1.MetricStatistic.AVERAGE,
                });
                if (fillWithZeroes ?? false) {
                    return this.createMetricMath(finalExpressionIdZeroed, { [finalExpressionId]: avgMetric }, avgLabel, avgMetric.color, avgMetric.period, this.getRegion(avgMetric), this.getAccount(avgMetric));
                }
                return avgMetric;
            case RateComputationMethod_1.RateComputationMethod.PER_SECOND:
                let perSecondLabel = `${labelPrefix}/s${labelAppendix}`;
                if (labelPrefix === "Requests" ||
                    labelPrefix === "Invocations" ||
                    labelPrefix === "Transactions") {
                    // currently, kept as "TPS" to reduce number of snapshot changes
                    perSecondLabel = `TPS${labelAppendix}`;
                }
                return this.createMetricMath(`${finalExpressionIdZeroed} / PERIOD(${finalExpressionId})`, { [finalExpressionId]: metric }, perSecondLabel, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
            case RateComputationMethod_1.RateComputationMethod.PER_MINUTE:
                return this.createMetricMath(`(60 * ${finalExpressionIdZeroed}) / PERIOD(${finalExpressionId})`, { [finalExpressionId]: metric }, `${labelPrefix}/m${labelAppendix}`, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
            case RateComputationMethod_1.RateComputationMethod.PER_HOUR:
                return this.createMetricMath(`(3600 * ${finalExpressionIdZeroed}) / PERIOD(${finalExpressionId})`, { [finalExpressionId]: metric }, `${labelPrefix}/h${labelAppendix}`, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
            case RateComputationMethod_1.RateComputationMethod.PER_DAY:
                return this.createMetricMath(`(86400 * ${finalExpressionIdZeroed}) / PERIOD(${finalExpressionId})`, { [finalExpressionId]: metric }, `${labelPrefix}/d${labelAppendix}`, metric.color, metric.period, this.getRegion(metric), this.getAccount(metric));
        }
    }
    /**
     * Returns the given namespace (if defined) or the global namespace as a fallback.
     * If there is no namespace to fallback to (neither the custom or the default one), it will fail.
     * @param value custom namespace
     */
    getNamespaceWithFallback(value) {
        const namespace = value ?? this.globalDefaults.namespace;
        if (!namespace) {
            throw new Error("There is no custom namespace defined. Please specify it in your factory defaults.");
        }
        return namespace;
    }
    /**
     * Helper method that helps to sanitize the given expression ID and removes all invalid characters.
     * Valid expression ID regexp is the following: ^[a-z][a-zA-Z0-9_]*$
     * As this is just to validate a suffix and not the whole ID, we do not have to verify the first lower case letter.
     * @param expressionId expression ID to sanitize
     */
    sanitizeMetricExpressionIdSuffix(expressionId) {
        return expressionId.replace(/[^0-9a-z_]/gi, "");
    }
    /**
     * Merges the given additional dimensions to the given target dimension hash.
     * All existing dimensions with the same key are replaced.
     * @param target target dimension hash to update
     * @param additionalDimensions additional dimensions
     */
    addAdditionalDimensions(target, additionalDimensions) {
        // Add additional dimensions in the search query
        Object.keys(additionalDimensions).forEach((key) => {
            target[key] = additionalDimensions[key];
        });
    }
    /**
     * Removes all entries from the given dimension hash that contain an undefined value.
     * @param dimensionsMap dimensions map to update
     */
    removeUndefinedEntries(dimensionsMap) {
        const copy = {};
        Object.entries(dimensionsMap)
            .filter(([_, value]) => value !== undefined)
            .forEach(([key, value]) => (copy[key] = value));
        return copy;
    }
    /**
     * Attempts to get the account from the metric if it differs from the scope.
     */
    resolveAccount(metricAccount) {
        if (!this.scope) {
            return metricAccount;
        }
        const { account } = aws_cdk_lib_1.Stack.of(this.scope);
        if (metricAccount !== account) {
            return metricAccount;
        }
        return;
    }
    getAccount(metric) {
        let metricAccount;
        if (metric instanceof aws_cloudwatch_1.MathExpression) {
            metricAccount = metric.searchAccount;
        }
        else {
            metricAccount = metric.account;
        }
        return this.resolveAccount(metricAccount);
    }
    /**
     * Attempts to get the region from the metric if it differs from the scope.
     */
    resolveRegion(metricRegion) {
        if (!this.scope) {
            return metricRegion;
        }
        const { region } = aws_cdk_lib_1.Stack.of(this.scope);
        if (metricRegion !== region) {
            return metricRegion;
        }
        return;
    }
    getRegion(metric) {
        let metricRegion;
        if (metric instanceof aws_cloudwatch_1.MathExpression) {
            metricRegion = metric.searchRegion;
        }
        else {
            metricRegion = metric.region;
        }
        return this.resolveRegion(metricRegion);
    }
}
exports.MetricFactory = MetricFactory;
_a = JSII_RTTI_SYMBOL_1;
MetricFactory[_a] = { fqn: "cdk-monitoring-constructs.MetricFactory", version: "8.1.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWV0cmljRmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIk1ldHJpY0ZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw2Q0FBOEM7QUFDOUMsK0RBS29DO0FBR3BDLHFGQUFrRjtBQUVsRix1REFBb0Q7QUFFcEQsbUVBQWdFO0FBRWhFOztHQUVHO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxzQkFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQXlCdkQsTUFBYSxhQUFhO0lBSXhCLG9GQUFvRjtJQUNwRixZQUFZLEtBQTBCLEVBQUUsS0FBaUI7UUFDdkQsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLEVBQUUsY0FBYyxJQUFJLEVBQUUsQ0FBQztRQUNsRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsWUFBWSxDQUNWLFVBQWtCLEVBQ2xCLFNBQTBCLEVBQzFCLEtBQWMsRUFDZCxhQUE2QixFQUM3QixLQUFjLEVBQ2QsU0FBa0IsRUFDbEIsTUFBaUIsRUFDakIsTUFBZSxFQUNmLE9BQWdCO1FBRWhCLE9BQU8sSUFBSSx1QkFBTSxDQUFDO1lBQ2hCLFNBQVM7WUFDVCxVQUFVO1lBQ1YsS0FBSztZQUNMLEtBQUs7WUFDTCxhQUFhLEVBQUUsYUFBYTtnQkFDMUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxhQUFhLENBQUM7Z0JBQzVDLENBQUMsQ0FBQyxTQUFTO1lBQ2IsU0FBUyxFQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUM7WUFDbkQsTUFBTSxFQUFFLE1BQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sSUFBSSwyQkFBbUI7WUFDbkUsTUFBTSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDO1lBQ2hFLE9BQU8sRUFB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Q0FBQyxhQUFhLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxhQUFhLENBQUMsWUFBZ0M7UUFDcEQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDZixPQUFPLFlBQVksQ0FBQztTQUNyQjtRQUVELE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxtQkFBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsSUFBSSxZQUFZLEtBQUssTUFBTSxFQUFFO1lBQzNCLE9BQU8sWUFBWSxDQUFDO1NBQ3JCO1FBRUQsT0FBTztJQUNULENBQUM7SUFDTyxTQUFTLENBQUMsTUFBOEI7UUFDOUMsSUFBSSxZQUFnQyxDQUFDO1FBQ3JDLElBQUksTUFBTSxZQUFZLCtCQUFjLEVBQUU7WUFDcEMsWUFBWSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7U0FDcEM7YUFBTTtZQUNMLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzFDLENBQUM7O0FBeGVILHNDQXllQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IER1cmF0aW9uLCBTdGFjayB9IGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuaW1wb3J0IHtcbiAgRGltZW5zaW9uc01hcCxcbiAgSU1ldHJpYyxcbiAgTWF0aEV4cHJlc3Npb24sXG4gIE1ldHJpYyxcbn0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1jbG91ZHdhdGNoXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuXG5pbXBvcnQgeyBBbm9tYWx5RGV0ZWN0aW9uTWF0aEV4cHJlc3Npb24gfSBmcm9tIFwiLi9Bbm9tYWx5RGV0ZWN0aW9uTWF0aEV4cHJlc3Npb25cIjtcbmltcG9ydCB7IEJhc2VNZXRyaWNGYWN0b3J5UHJvcHMgfSBmcm9tIFwiLi9CYXNlTWV0cmljRmFjdG9yeVwiO1xuaW1wb3J0IHsgTWV0cmljU3RhdGlzdGljIH0gZnJvbSBcIi4vTWV0cmljU3RhdGlzdGljXCI7XG5pbXBvcnQgeyBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0IH0gZnJvbSBcIi4vTWV0cmljV2l0aEFsYXJtU3VwcG9ydFwiO1xuaW1wb3J0IHsgUmF0ZUNvbXB1dGF0aW9uTWV0aG9kIH0gZnJvbSBcIi4vUmF0ZUNvbXB1dGF0aW9uTWV0aG9kXCI7XG5cbi8qKlxuICogVGhlIG1vc3QgY29tbW9uIGRlZmF1bHQgbWV0cmljIHBlcmlvZCB1c2VkIGF0IEFtYXpvbiBpcyBjdXJyZW50bHkgNSBtaW51dGVzLlxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdE1ldHJpY1BlcmlvZCA9IER1cmF0aW9uLm1pbnV0ZXMoNSk7XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBnbG9iYWxzIHVzZWQgZm9yIGVhY2ggbWV0cmljLCB1bmxlc3MgdGhlcmUgaXMgc29tZSBraW5kIG9mIG92ZXJyaWRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0ZhY3RvcnlEZWZhdWx0cyBleHRlbmRzIEJhc2VNZXRyaWNGYWN0b3J5UHJvcHMge1xuICAvKipcbiAgICogRWFjaCBtZXRyaWMgZXhpc3RzIGluIGEgbmFtZXNwYWNlLiBBV1MgU2VydmljZXMgaGF2ZSB0aGVpciBvd24gbmFtZXNwYWNlLCBidXQgaGVyZSB5b3UgY2FuIHNwZWNpZnkgeW91ciBjdXN0b20gb25lLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNZXRyaWMgcGVyaW9kLiBEZWZhdWx0IHZhbHVlIGlzIHVzZWQgaWYgbm90IGRlZmluZWQuXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdE1ldHJpY1BlcmlvZFxuICAgKi9cbiAgcmVhZG9ubHkgcGVyaW9kPzogRHVyYXRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljRmFjdG9yeVByb3BzIHtcbiAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZ2xvYmFsIGRlZmF1bHRzLCB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaW5kaXZpZHVhbCBtZXRyaWNzIG9yIGFsYXJtcy5cbiAgICovXG4gIHJlYWRvbmx5IGdsb2JhbERlZmF1bHRzPzogTWV0cmljRmFjdG9yeURlZmF1bHRzO1xufVxuXG5leHBvcnQgY2xhc3MgTWV0cmljRmFjdG9yeSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBnbG9iYWxEZWZhdWx0czogTWV0cmljRmFjdG9yeURlZmF1bHRzO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2NvcGU6IENvbnN0cnVjdCB8IHVuZGVmaW5lZDtcblxuICAvLyBUT0RPOiBtYWtlIHNjb3BlIHJlcXVpcmVkIGFuZCBmaXJzdC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgZm9yIG5vdy5cbiAgY29uc3RydWN0b3IocHJvcHM/OiBNZXRyaWNGYWN0b3J5UHJvcHMsIHNjb3BlPzogQ29uc3RydWN0KSB7XG4gICAgdGhpcy5nbG9iYWxEZWZhdWx0cyA9IHByb3BzPy5nbG9iYWxEZWZhdWx0cyA/PyB7fTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgbWV0cmljLiBUaGUgbWV0cmljIHByb3BlcnRpZXMgd2lsbCBhbHJlYWR5IGJlIHVwZGF0ZWQgdG8gY29tcGx5IHdpdGggdGhlIGdsb2JhbCBkZWZhdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIG1ldHJpY05hbWUgbWV0cmljIG5hbWVcbiAgICogQHBhcmFtIHN0YXRpc3RpYyBhZ2dyZWdhdGlvbiBzdGF0aXN0aWMgdG8gdXNlXG4gICAqIEBwYXJhbSBsYWJlbCBtZXRyaWMgbGFiZWw7IGlmIHVuZGVmaW5lZCwgbWV0cmljIG5hbWUgaXMgdXNlZCBieSBDbG91ZFdhdGNoXG4gICAqIEBwYXJhbSBkaW1lbnNpb25zTWFwIGFkZGl0aW9uYWwgZGltZW5zaW9ucyB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gY29sb3IgbWV0cmljIGNvbG9yOyBpZiB1bmRlZmluZWQsIHVzZXMgYSBDbG91ZFdhdGNoIHByb3ZpZGVkIGNvbG9yIChwcmVmZXJyZWQpXG4gICAqIEBwYXJhbSBuYW1lc3BhY2Ugc3BlY2lmeSBhIGN1c3RvbSBuYW1lc3BhY2U7IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAgICogQHBhcmFtIHBlcmlvZCBzcGVjaWZ5IGEgY3VzdG9tIHBlcmlvZDsgaWYgdW5kZWZpbmVkLCB1c2VzIHRoZSBnbG9iYWwgZGVmYXVsdFxuICAgKiBAcGFyYW0gcmVnaW9uIHNwZWNpZnkgYSBjdXN0b20gcmVnaW9uOyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqIEBwYXJhbSBhY2NvdW50IHNwZWNpZnkgYSBjdXN0b20gYWNjb3VudDsgaWYgdW5kZWZpbmVkLCB1c2VzIHRoZSBnbG9iYWwgZGVmYXVsdFxuICAgKi9cbiAgY3JlYXRlTWV0cmljKFxuICAgIG1ldHJpY05hbWU6IHN0cmluZyxcbiAgICBzdGF0aXN0aWM6IE1ldHJpY1N0YXRpc3RpYyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBkaW1lbnNpb25zTWFwPzogRGltZW5zaW9uc01hcCxcbiAgICBjb2xvcj86IHN0cmluZyxcbiAgICBuYW1lc3BhY2U/OiBzdHJpbmcsXG4gICAgcGVyaW9kPzogRHVyYXRpb24sXG4gICAgcmVnaW9uPzogc3RyaW5nLFxuICAgIGFjY291bnQ/OiBzdHJpbmcsXG4gICk6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQge1xuICAgIHJldHVybiBuZXcgTWV0cmljKHtcbiAgICAgIHN0YXRpc3RpYyxcbiAgICAgIG1ldHJpY05hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGNvbG9yLFxuICAgICAgZGltZW5zaW9uc01hcDogZGltZW5zaW9uc01hcFxuICAgICAgICA/IHRoaXMucmVtb3ZlVW5kZWZpbmVkRW50cmllcyhkaW1lbnNpb25zTWFwKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIG5hbWVzcGFjZTogdGhpcy5nZXROYW1lc3BhY2VXaXRoRmFsbGJhY2sobmFtZXNwYWNlKSxcbiAgICAgIHBlcmlvZDogcGVyaW9kID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMucGVyaW9kID8/IERlZmF1bHRNZXRyaWNQZXJpb2QsXG4gICAgICByZWdpb246IHRoaXMucmVzb2x2ZVJlZ2lvbihyZWdpb24gPz8gdGhpcy5nbG9iYWxEZWZhdWx0cy5yZWdpb24pLFxuICAgICAgYWNjb3VudDogdGhpcy5yZXNvbHZlQWNjb3VudChhY2NvdW50ID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMuYWNjb3VudCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgbWV0cmljIG1hdGggZXhwcmVzc2lvbi4gVGhlIG1ldHJpYyBwcm9wZXJ0aWVzIHdpbGwgYWxyZWFkeSBiZSB1cGRhdGVkIHRvIGNvbXBseSB3aXRoIHRoZSBnbG9iYWwgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSBleHByZXNzaW9uIENsb3VkV2F0Y2ggbWV0cmljIG1hdGggZXhwcmVzc2lvbiAoaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkNsb3VkV2F0Y2gvbGF0ZXN0L21vbml0b3JpbmcvdXNpbmctbWV0cmljLW1hdGguaHRtbClcbiAgICogQHBhcmFtIHVzaW5nTWV0cmljcyBtYXAgb2YgbWV0cmljcywgd2hlcmUga2V5cyBhcmUgZXhwcmVzc2lvbiBJRHMgKHVzZWQgaW4gdGhlIGV4cHJlc3Npb24pIGFuZCB2YWx1ZXMgYXJlIG1ldHJpY3NcbiAgICogQHBhcmFtIGxhYmVsIG1ldHJpYyBsYWJlbCAocmVxdWlyZWQsIGFzIHRoZXJlIGlzIG5vIHJlYXNvbmFibGUgZGVmYXVsdClcbiAgICogQHBhcmFtIGNvbG9yIG1ldHJpYyBjb2xvcjsgaWYgdW5kZWZpbmVkLCB1c2VzIGEgQ2xvdWRXYXRjaCBwcm92aWRlZCBjb2xvciAocHJlZmVycmVkKVxuICAgKiBAcGFyYW0gcGVyaW9kIHNwZWNpZnkgYSBjdXN0b20gcGVyaW9kOyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqIEBwYXJhbSByZWdpb24gc3BlY2lmeSBhIGN1c3RvbSByZWdpb247IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAgICogQHBhcmFtIGFjY291bnQgc3BlY2lmeSBhIGN1c3RvbSBhY2NvdW50OyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqL1xuICBjcmVhdGVNZXRyaWNNYXRoKFxuICAgIGV4cHJlc3Npb246IHN0cmluZyxcbiAgICB1c2luZ01ldHJpY3M6IFJlY29yZDxzdHJpbmcsIElNZXRyaWM+LFxuICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgY29sb3I/OiBzdHJpbmcsXG4gICAgcGVyaW9kPzogRHVyYXRpb24sXG4gICAgcmVnaW9uPzogc3RyaW5nLFxuICAgIGFjY291bnQ/OiBzdHJpbmcsXG4gICk6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQge1xuICAgIHJldHVybiBuZXcgTWF0aEV4cHJlc3Npb24oe1xuICAgICAgbGFiZWwsXG4gICAgICBjb2xvcixcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgICB1c2luZ01ldHJpY3MsXG4gICAgICBwZXJpb2Q6IHBlcmlvZCA/PyB0aGlzLmdsb2JhbERlZmF1bHRzLnBlcmlvZCA/PyBEZWZhdWx0TWV0cmljUGVyaW9kLFxuICAgICAgc2VhcmNoUmVnaW9uOiB0aGlzLnJlc29sdmVSZWdpb24ocmVnaW9uID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMucmVnaW9uKSxcbiAgICAgIHNlYXJjaEFjY291bnQ6IHRoaXMucmVzb2x2ZUFjY291bnQoXG4gICAgICAgIGFjY291bnQgPz8gdGhpcy5nbG9iYWxEZWZhdWx0cy5hY2NvdW50LFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBtZXRyaWMgc2VhcmNoIHF1ZXJ5LiBUaGUgbWV0cmljIHByb3BlcnRpZXMgd2lsbCBhbHJlYWR5IGJlIHVwZGF0ZWQgdG8gY29tcGx5IHdpdGggdGhlIGdsb2JhbCBkZWZhdWx0cy5cbiAgICogSWYgeW91IHdhbnQgdG8gbWF0Y2ggXCJhbnkgdmFsdWVcIiBvZiBhIHNwZWNpZmljIGRpbWVuc2lvbiwgcGxlYXNlIHVzZSBgdW5kZWZpbmVkYCB2YWx1ZSByZXByZXNlbnRhdGlvbiBpbiB5b3VyIGNvbnN1bWVyIGxhbmd1YWdlLlxuICAgKiAoRm9yIGV4YW1wbGUsIGB1bmRlZmluZWQgYXMgYW55IGFzIHN0cmluZ2AgaW4gVHlwZVNjcmlwdCwgZHVlIHRvIEpTSUkgdHlwaW5nIHF1aXJrcy4pXG4gICAqXG4gICAqIEBwYXJhbSBxdWVyeSBtZXRyaWMgc2VhcmNoIHF1ZXJ5ICh0aGUgc2FtZSBhcyB0aGUgc2VhcmNoIHF1ZXJ5IHByb21wdCBpbiBDbG91ZFdhdGNoIEFXUyBDb25zb2xlKSwgaXQgbWlnaHQgYWxzbyBiZSBlbXB0eVxuICAgKiBAcGFyYW0gZGltZW5zaW9uc01hcCBkaW1lbnNpb25zLCBmdXJ0aGVyIG5hcnJvd2luZyB0aGUgc2VhcmNoIHJlc3VsdHM7IHVzZSBgdW5kZWZpbmVkYCBpZiB5b3Ugd2FudCB0byByZXByZXNlbnQgXCJhbnkgdmFsdWVcIiAoaW4gVFM6IGB1bmRlZmluZWQgYXMgYW55IGFzIHN0cmluZ2ApXG4gICAqIEBwYXJhbSBzdGF0aXN0aWMgYWdncmVnYXRpb24gc3RhdGlzdGljIHRvIHVzZVxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIHNwZWNpZnkgYSBjdXN0b20gbmFtZXNwYWNlOyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqIEBwYXJhbSBsYWJlbCBzcGVjaWZ5IGN1c3RvbSBsYWJlbCBmb3Igc2VhcmNoIG1ldHJpY3M7IGRlZmF1bHQgaXMgXCIgXCIgYXMgaXQgY2Fubm90IGJlIGVtcHR5IHN0cmluZ1xuICAgKiBAcGFyYW0gcGVyaW9kIHNwZWNpZnkgYSBjdXN0b20gcGVyaW9kOyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqIEBwYXJhbSByZWdpb24gc3BlY2lmeSBhIGN1c3RvbSByZWdpb247IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAgICogQHBhcmFtIGFjY291bnQgc3BlY2lmeSBhIGN1c3RvbSBhY2NvdW50OyBpZiB1bmRlZmluZWQsIHVzZXMgdGhlIGdsb2JhbCBkZWZhdWx0XG4gICAqL1xuICBjcmVhdGVNZXRyaWNTZWFyY2goXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBkaW1lbnNpb25zTWFwOiBEaW1lbnNpb25zTWFwLFxuICAgIHN0YXRpc3RpYzogTWV0cmljU3RhdGlzdGljLFxuICAgIG5hbWVzcGFjZT86IHN0cmluZyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBwZXJpb2Q/OiBEdXJhdGlvbixcbiAgICByZWdpb24/OiBzdHJpbmcsXG4gICAgYWNjb3VudD86IHN0cmluZyxcbiAgKTogSU1ldHJpYyB7XG4gICAgY29uc3QgZmluYWxQZXJpb2QgPVxuICAgICAgcGVyaW9kID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMucGVyaW9kID8/IERlZmF1bHRNZXRyaWNQZXJpb2Q7XG4gICAgY29uc3Qgc2VhcmNoTmFtZXNwYWNlID0gdGhpcy5nZXROYW1lc3BhY2VXaXRoRmFsbGJhY2sobmFtZXNwYWNlKTtcbiAgICBjb25zdCBuYW1lc3BhY2VQbHVzRGltZW5zaW9uS2V5cyA9IFtcbiAgICAgIHNlYXJjaE5hbWVzcGFjZSxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGRpbWVuc2lvbnNNYXApLFxuICAgIF0uam9pbihcIixcIik7XG4gICAgY29uc3QgbWV0cmljU2NoZW1hID0gYHske25hbWVzcGFjZVBsdXNEaW1lbnNpb25LZXlzfX1gO1xuXG4gICAgY29uc3QgZGltZW5zaW9uS2V5c0FuZFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKFxuICAgICAgdGhpcy5yZW1vdmVVbmRlZmluZWRFbnRyaWVzKGRpbWVuc2lvbnNNYXApLFxuICAgIClcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT1cIiR7dmFsdWV9XCJgKVxuICAgICAgLmpvaW4oXCIgXCIpO1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGBTRUFSQ0goJyR7bWV0cmljU2NoZW1hfSAke2RpbWVuc2lvbktleXNBbmRWYWx1ZXN9ICR7cXVlcnl9JywgJyR7c3RhdGlzdGljfScsICR7ZmluYWxQZXJpb2QudG9TZWNvbmRzKCl9KWA7XG5cbiAgICByZXR1cm4gbmV3IE1hdGhFeHByZXNzaW9uKHtcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy83MjM3XG4gICAgICB1c2luZ01ldHJpY3M6IHt9LFxuICAgICAgLy8gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZyBhbmQgdW5kZWZpbmVkIGlzIG5vIGdvb2QgZWl0aGVyXG4gICAgICBsYWJlbDogbGFiZWwgPz8gXCIgXCIsXG4gICAgICBwZXJpb2Q6IGZpbmFsUGVyaW9kLFxuICAgICAgc2VhcmNoUmVnaW9uOiB0aGlzLnJlc29sdmVSZWdpb24ocmVnaW9uID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMucmVnaW9uKSxcbiAgICAgIHNlYXJjaEFjY291bnQ6IHRoaXMucmVzb2x2ZUFjY291bnQoXG4gICAgICAgIGFjY291bnQgPz8gdGhpcy5nbG9iYWxEZWZhdWx0cy5hY2NvdW50LFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IGNyZWF0ZXMgYW5vbWFseSBkZXRlY3Rpb24gb24gYSBtZXRyaWMuXG4gICAqIEFub21hbHkgb2NjdXJzIHdoZW5ldmVyIGEgbWV0cmljIHZhbHVlIGZhbGxzIG91dHNpZGUgb2YgYSBwcmVjb21wdXRlZCByYW5nZSBvZiBwcmVkaWN0ZWQgdmFsdWVzLlxuICAgKiBUaGUgZGV0ZWN0aW9uIGRvZXMgbm90IG5lZWQgYW55IHNldHVwLiBUaGUgbW9kZWwgd2lsbCBzdGFydCBsZWFybmluZyBhdXRvbWF0aWNhbGx5IGFuZCBzaG91bGQgYmUgcmVhZHkgaW4gYSBmZXcgbWludXRlcy5cbiAgICogVXN1YWxseSwgdGhlIGFub21hbHkgZGV0ZWN0aW9uIGlzIHBhaXJlZCB3aXRoIGFuIGFsYXJtLlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25DbG91ZFdhdGNoL2xhdGVzdC9tb25pdG9yaW5nL0Nsb3VkV2F0Y2hfQW5vbWFseV9EZXRlY3Rpb24uaHRtbFxuICAgKlxuICAgKiBAcGFyYW0gbWV0cmljIG1ldHJpYyB0byBkZXRlY3QgYW5vbWFseSBkZXRlY3Rpb24gb2ZcbiAgICogQHBhcmFtIHN0ZGV2IHN0YW5kYXJkIGRldmlhdGlvbiwgYmFzaWNhbGx5IHRoZSB0b2xlcmFuY2UgLyBiYW5kIHRoaWNrbmVzc1xuICAgKiBAcGFyYW0gbGFiZWwgbWV0cmljIGxhYmVsIChyZXF1aXJlZCwgYXMgdGhlcmUgaXMgbm8gcmVhc29uYWJsZSBkZWZhdWx0KVxuICAgKiBAcGFyYW0gY29sb3IgbWV0cmljIGNvbG9yOyBpZiB1bmRlZmluZWQsIHVzZXMgYSBDbG91ZFdhdGNoIHByb3ZpZGVkIGNvbG9yIChwcmVmZXJyZWQpXG4gICAqIEBwYXJhbSBleHByZXNzaW9uSWQgZXhwcmVzc2lvbiBJRCBvZiB0aGUgbWV0cmljOyB1c2VzIGBtMWAgaWYgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBwZXJpb2Qgc3BlY2lmeSBhIGN1c3RvbSBwZXJpb2Q7IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAgICogQHBhcmFtIHJlZ2lvbiBzcGVjaWZ5IGEgY3VzdG9tIHJlZ2lvbjsgaWYgdW5kZWZpbmVkLCB1c2VzIHRoZSBnbG9iYWwgZGVmYXVsdFxuICAgKiBAcGFyYW0gYWNjb3VudCBzcGVjaWZ5IGEgY3VzdG9tIGFjY291bnQ7IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZ2xvYmFsIGRlZmF1bHRcbiAgICovXG4gIGNyZWF0ZU1ldHJpY0Fub21hbHlEZXRlY3Rpb24oXG4gICAgbWV0cmljOiBJTWV0cmljLFxuICAgIHN0ZGV2OiBudW1iZXIsXG4gICAgbGFiZWw6IHN0cmluZyxcbiAgICBjb2xvcj86IHN0cmluZyxcbiAgICBleHByZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgcGVyaW9kPzogRHVyYXRpb24sXG4gICAgcmVnaW9uPzogc3RyaW5nLFxuICAgIGFjY291bnQ/OiBzdHJpbmcsXG4gICk6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQge1xuICAgIGNvbnN0IGZpbmFsRXhwcmVzc2lvbklkID0gZXhwcmVzc2lvbklkID8/IFwibTFcIjtcbiAgICBjb25zdCB1c2luZ01ldHJpY3M6IFJlY29yZDxzdHJpbmcsIElNZXRyaWM+ID0ge307XG4gICAgdXNpbmdNZXRyaWNzW2ZpbmFsRXhwcmVzc2lvbklkXSA9IG1ldHJpYztcbiAgICByZXR1cm4gbmV3IEFub21hbHlEZXRlY3Rpb25NYXRoRXhwcmVzc2lvbih7XG4gICAgICBsYWJlbCxcbiAgICAgIGNvbG9yLFxuICAgICAgdXNpbmdNZXRyaWNzLFxuICAgICAgZXhwcmVzc2lvbjogYEFOT01BTFlfREVURUNUSU9OX0JBTkQoJHtmaW5hbEV4cHJlc3Npb25JZH0sJHtzdGRldn0pYCxcbiAgICAgIHBlcmlvZDogcGVyaW9kID8/IHRoaXMuZ2xvYmFsRGVmYXVsdHMucGVyaW9kID8/IERlZmF1bHRNZXRyaWNQZXJpb2QsXG4gICAgICBzZWFyY2hSZWdpb246IHRoaXMucmVzb2x2ZVJlZ2lvbihyZWdpb24gPz8gdGhpcy5nbG9iYWxEZWZhdWx0cy5yZWdpb24pLFxuICAgICAgc2VhcmNoQWNjb3VudDogdGhpcy5yZXNvbHZlQWNjb3VudChcbiAgICAgICAgYWNjb3VudCA/PyB0aGlzLmdsb2JhbERlZmF1bHRzLmFjY291bnQsXG4gICAgICApLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkYXB0cyBwcm9wZXJ0aWVzIG9mIGEgZm9yZWlnbiBtZXRyaWMgKG1ldHJpYyBjcmVhdGVkIG91dHNpZGUgb2YgdGhpcyBtZXRyaWMgZmFjdG9yeSkgdG8gY29tcGx5IHdpdGggdGhlIGdsb2JhbCBkZWZhdWx0cy5cbiAgICogTWlnaHQgbW9kaWZ5IG5hbWVzcGFjZSBhbmQgbWV0cmljIHBlcmlvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldHJpYyBtZXRyaWMgdG8gYmUgYWRhcHRlZFxuICAgKi9cbiAgYWRhcHRNZXRyaWMobWV0cmljOiBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0KTogTWV0cmljV2l0aEFsYXJtU3VwcG9ydCB7XG4gICAgcmV0dXJuIG1ldHJpYy53aXRoKHtcbiAgICAgIHBlcmlvZDogdGhpcy5nbG9iYWxEZWZhdWx0cy5wZXJpb2QgPz8gRGVmYXVsdE1ldHJpY1BlcmlvZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGFwdHMgcHJvcGVydGllcyBvZiBhIGZvcmVpZ24gbWV0cmljIChtZXRyaWMgY3JlYXRlZCBvdXRzaWRlIG9mIHRoaXMgbWV0cmljIGZhY3RvcnkpIHRvIGNvbXBseSB3aXRoIHRoZSBnbG9iYWwgZGVmYXVsdHMuXG4gICAqIE1pZ2h0IG1vZGlmeSBuYW1lc3BhY2UuIFByZXNlcnZlcyBtZXRyaWMgcGVyaW9kLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0cmljIG1ldHJpYyB0byBiZSBhZGFwdGVkXG4gICAqL1xuICBhZGFwdE1ldHJpY1ByZXNlcnZpbmdQZXJpb2QoXG4gICAgbWV0cmljOiBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0LFxuICApOiBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0IHtcbiAgICByZXR1cm4gbWV0cmljO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtZXRyaWMgbWF0aCBleHByZXNzaW9uIHRoYXQgbXVsdGlwbGllcyB0aGUgZ2l2ZW4gbWV0cmljIGJ5IGdpdmVuIGNvZWZmaWNpZW50LlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIG11bHRpcGxpZXIgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIG1ldHJpYyBwZXJpb2QuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRyaWMgbWV0cmljIHRvIG11bHRpcGx5XG4gICAqIEBwYXJhbSBtdWx0aXBsaWVyIG11bHRpcGxpZXIgKG11c3QgYmUgPiAxKVxuICAgKiBAcGFyYW0gbGFiZWwgZXhwcmVzc2lvbiBsYWJlbFxuICAgKiBAcGFyYW0gZXhwcmVzc2lvbklkIGV4cHJlc3Npb24gSUQgb2YgdGhlIG1ldHJpYzsgdXNlcyBgbTFgIGlmIHVuZGVmaW5lZFxuICAgKi9cbiAgbXVsdGlwbHlNZXRyaWMoXG4gICAgbWV0cmljOiBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0LFxuICAgIG11bHRpcGxpZXI6IG51bWJlcixcbiAgICBsYWJlbDogc3RyaW5nLFxuICAgIGV4cHJlc3Npb25JZD86IHN0cmluZyxcbiAgKTogTWV0cmljV2l0aEFsYXJtU3VwcG9ydCB7XG4gICAgaWYgKG11bHRpcGxpZXIgPT0gMSkge1xuICAgICAgcmV0dXJuIG1ldHJpYztcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsaWVyIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9uZS5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmFsRXhwcmVzc2lvbklkID0gZXhwcmVzc2lvbklkID8/IFwibTFcIjtcbiAgICAgIGNvbnN0IHVzaW5nTWV0cmljczogUmVjb3JkPHN0cmluZywgSU1ldHJpYz4gPSB7fTtcbiAgICAgIHVzaW5nTWV0cmljc1tmaW5hbEV4cHJlc3Npb25JZF0gPSBtZXRyaWM7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNZXRyaWNNYXRoKFxuICAgICAgICBgJHtmaW5hbEV4cHJlc3Npb25JZH0gKiAke211bHRpcGxpZXJ9YCxcbiAgICAgICAgdXNpbmdNZXRyaWNzLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgbWV0cmljLmNvbG9yLFxuICAgICAgICBtZXRyaWMucGVyaW9kLFxuICAgICAgICB0aGlzLmdldFJlZ2lvbihtZXRyaWMpLFxuICAgICAgICB0aGlzLmdldEFjY291bnQobWV0cmljKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtZXRyaWMgbWF0aCBleHByZXNzaW9uIHRoYXQgZGl2aWRlcyB0aGUgZ2l2ZW4gbWV0cmljIGJ5IGdpdmVuIGNvZWZmaWNpZW50LlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIGRpdmlzb3IgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIG1ldHJpYyBwZXJpb2QuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRyaWMgbWV0cmljIHRvIG11bHRpcGx5XG4gICAqIEBwYXJhbSBkaXZpc29yIGRpdmlzb3IgKG11c3QgYmUgPiAxKVxuICAgKiBAcGFyYW0gbGFiZWwgZXhwcmVzc2lvbiBsYWJlbFxuICAgKiBAcGFyYW0gZXhwcmVzc2lvbklkIGV4cHJlc3Npb24gSUQgb2YgdGhlIG1ldHJpYzsgdXNlcyBgbTFgIGlmIHVuZGVmaW5lZFxuICAgKi9cbiAgZGl2aWRlTWV0cmljKFxuICAgIG1ldHJpYzogTWV0cmljV2l0aEFsYXJtU3VwcG9ydCxcbiAgICBkaXZpc29yOiBudW1iZXIsXG4gICAgbGFiZWw6IHN0cmluZyxcbiAgICBleHByZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICk6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQge1xuICAgIGlmIChkaXZpc29yID09IDEpIHtcbiAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgfSBlbHNlIGlmIChkaXZpc29yIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNvciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvbmUuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaW5hbEV4cHJlc3Npb25JZCA9IGV4cHJlc3Npb25JZCA/PyBcIm0xXCI7XG4gICAgICBjb25zdCB1c2luZ01ldHJpY3M6IFJlY29yZDxzdHJpbmcsIElNZXRyaWM+ID0ge307XG4gICAgICB1c2luZ01ldHJpY3NbZmluYWxFeHByZXNzaW9uSWRdID0gbWV0cmljO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTWV0cmljTWF0aChcbiAgICAgICAgYCR7ZmluYWxFeHByZXNzaW9uSWR9IC8gJHtkaXZpc29yfWAsXG4gICAgICAgIHVzaW5nTWV0cmljcyxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIG1ldHJpYy5jb2xvcixcbiAgICAgICAgbWV0cmljLnBlcmlvZCxcbiAgICAgICAgdGhpcy5nZXRSZWdpb24obWV0cmljKSxcbiAgICAgICAgdGhpcy5nZXRBY2NvdW50KG1ldHJpYyksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWV0cmljIG1hdGggZXhwcmVzc2lvbiB0aGF0IGNvbXB1dGVzIGEgcmF0ZSBmcm9tIGEgcmVndWxhciBtZXRyaWMuXG4gICAqIEZvciBleGFtcGxlLCBpdCBhbGxvd3MgeW91IHRvIGNvbXB1dGUgcmF0ZSBwZXIgc2Vjb25kIChUUFMpLCBwZXIgbWludXRlLCBvciBqdXN0IGFuIGF2ZXJhZ2Ugb2YgeW91ciB0cmFuc2FjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRyaWMgbWV0cmljIHRvIGNhbGN1bGF0ZSB0aGUgcmF0ZSBmcm9tXG4gICAqIEBwYXJhbSBtZXRob2QgcmF0ZSBjb21wdXRhdGlvbiBtZXRob2RcbiAgICogQHBhcmFtIGFkZFN0YXRzVG9MYWJlbCBhZGQgZGV0YWlsZWQgc3RhdGlzdGljcyAobWluLCBtYXgsIGF2ZXJhZ2UpIHRvIHRoZSBsYWJlbFxuICAgKiBAcGFyYW0gZXhwcmVzc2lvbklkIGV4cHJlc3Npb24gSUQgb2YgdGhlIG1ldHJpYzsgdXNlcyBgbTFgIGlmIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gZmlsbFdpdGhaZXJvZXMgaWYgVFJVRSwgdGhlIGZpbmFsIG1ldHJpYyB3aWxsIGJlIHplcm8tZmlsbGVkICgwIG9uIG5vIGRhdGEpOyBmYWxzZSBpZiB1bmRlZmluZWRcbiAgICovXG4gIHRvUmF0ZShcbiAgICBtZXRyaWM6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQsXG4gICAgbWV0aG9kOiBSYXRlQ29tcHV0YXRpb25NZXRob2QsXG4gICAgYWRkU3RhdHNUb0xhYmVsPzogYm9vbGVhbixcbiAgICBleHByZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgZmlsbFdpdGhaZXJvZXM/OiBib29sZWFuLFxuICApOiBNZXRyaWNXaXRoQWxhcm1TdXBwb3J0IHtcbiAgICBjb25zdCBmaW5hbEV4cHJlc3Npb25JZCA9IGV4cHJlc3Npb25JZCA/PyBcIm0xXCI7XG4gICAgY29uc3QgbGFiZWxQcmVmaXggPSBtZXRyaWMubGFiZWwgPz8gXCJSYXRlXCI7XG5cbiAgICBjb25zdCBzdGF0c0luTGFiZWw6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGFkZFN0YXRzVG9MYWJlbCA/PyBmYWxzZSkge1xuICAgICAgc3RhdHNJbkxhYmVsLnB1c2goXCJtaW46ICR7TUlOfVwiKTtcbiAgICAgIHN0YXRzSW5MYWJlbC5wdXNoKFwibWF4OiAke01BWH1cIik7XG4gICAgICBpZiAobWV0aG9kICE9PSBSYXRlQ29tcHV0YXRpb25NZXRob2QuQVZFUkFHRSkge1xuICAgICAgICAvLyBvbmx5IGFkZCBhdmVyYWdlIGlmIGRvIG5vdCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgc3RhdHNJbkxhYmVsLnB1c2goXCJhdmc6ICR7QVZHfVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaW5hbEV4cHJlc3Npb25JZFplcm9lZCA9XG4gICAgICBmaWxsV2l0aFplcm9lcyA/PyBmYWxzZVxuICAgICAgICA/IGBGSUxMKCR7ZmluYWxFeHByZXNzaW9uSWR9LDApYFxuICAgICAgICA6IGZpbmFsRXhwcmVzc2lvbklkO1xuICAgIGNvbnN0IGxhYmVsQXBwZW5kaXggPVxuICAgICAgc3RhdHNJbkxhYmVsLmxlbmd0aCA+IDAgPyBgICgke3N0YXRzSW5MYWJlbC5qb2luKFwiLCBcIil9KWAgOiBcIlwiO1xuXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgUmF0ZUNvbXB1dGF0aW9uTWV0aG9kLkFWRVJBR0U6XG4gICAgICAgIGNvbnN0IGF2Z0xhYmVsID0gYCR7bGFiZWxQcmVmaXh9IChhdmcpJHtsYWJlbEFwcGVuZGl4fWA7XG4gICAgICAgIGNvbnN0IGF2Z01ldHJpYyA9IG1ldHJpYy53aXRoKHtcbiAgICAgICAgICBsYWJlbDogYXZnTGFiZWwsXG4gICAgICAgICAgc3RhdGlzdGljOiBNZXRyaWNTdGF0aXN0aWMuQVZFUkFHRSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWxsV2l0aFplcm9lcyA/PyBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU1ldHJpY01hdGgoXG4gICAgICAgICAgICBmaW5hbEV4cHJlc3Npb25JZFplcm9lZCxcbiAgICAgICAgICAgIHsgW2ZpbmFsRXhwcmVzc2lvbklkXTogYXZnTWV0cmljIH0sXG4gICAgICAgICAgICBhdmdMYWJlbCxcbiAgICAgICAgICAgIGF2Z01ldHJpYy5jb2xvcixcbiAgICAgICAgICAgIGF2Z01ldHJpYy5wZXJpb2QsXG4gICAgICAgICAgICB0aGlzLmdldFJlZ2lvbihhdmdNZXRyaWMpLFxuICAgICAgICAgICAgdGhpcy5nZXRBY2NvdW50KGF2Z01ldHJpYyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXZnTWV0cmljO1xuICAgICAgY2FzZSBSYXRlQ29tcHV0YXRpb25NZXRob2QuUEVSX1NFQ09ORDpcbiAgICAgICAgbGV0IHBlclNlY29uZExhYmVsID0gYCR7bGFiZWxQcmVmaXh9L3Mke2xhYmVsQXBwZW5kaXh9YDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxhYmVsUHJlZml4ID09PSBcIlJlcXVlc3RzXCIgfHxcbiAgICAgICAgICBsYWJlbFByZWZpeCA9PT0gXCJJbnZvY2F0aW9uc1wiIHx8XG4gICAgICAgICAgbGFiZWxQcmVmaXggPT09IFwiVHJhbnNhY3Rpb25zXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gY3VycmVudGx5LCBrZXB0IGFzIFwiVFBTXCIgdG8gcmVkdWNlIG51bWJlciBvZiBzbmFwc2hvdCBjaGFuZ2VzXG4gICAgICAgICAgcGVyU2Vjb25kTGFiZWwgPSBgVFBTJHtsYWJlbEFwcGVuZGl4fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTWV0cmljTWF0aChcbiAgICAgICAgICBgJHtmaW5hbEV4cHJlc3Npb25JZFplcm9lZH0gLyBQRVJJT0QoJHtmaW5hbEV4cHJlc3Npb25JZH0pYCxcbiAgICAgICAgICB7IFtmaW5hbEV4cHJlc3Npb25JZF06IG1ldHJpYyB9LFxuICAgICAgICAgIHBlclNlY29uZExhYmVsLFxuICAgICAgICAgIG1ldHJpYy5jb2xvcixcbiAgICAgICAgICBtZXRyaWMucGVyaW9kLFxuICAgICAgICAgIHRoaXMuZ2V0UmVnaW9uKG1ldHJpYyksXG4gICAgICAgICAgdGhpcy5nZXRBY2NvdW50KG1ldHJpYyksXG4gICAgICAgICk7XG4gICAgICBjYXNlIFJhdGVDb21wdXRhdGlvbk1ldGhvZC5QRVJfTUlOVVRFOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNZXRyaWNNYXRoKFxuICAgICAgICAgIGAoNjAgKiAke2ZpbmFsRXhwcmVzc2lvbklkWmVyb2VkfSkgLyBQRVJJT0QoJHtmaW5hbEV4cHJlc3Npb25JZH0pYCxcbiAgICAgICAgICB7IFtmaW5hbEV4cHJlc3Npb25JZF06IG1ldHJpYyB9LFxuICAgICAgICAgIGAke2xhYmVsUHJlZml4fS9tJHtsYWJlbEFwcGVuZGl4fWAsXG4gICAgICAgICAgbWV0cmljLmNvbG9yLFxuICAgICAgICAgIG1ldHJpYy5wZXJpb2QsXG4gICAgICAgICAgdGhpcy5nZXRSZWdpb24obWV0cmljKSxcbiAgICAgICAgICB0aGlzLmdldEFjY291bnQobWV0cmljKSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUmF0ZUNvbXB1dGF0aW9uTWV0aG9kLlBFUl9IT1VSOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNZXRyaWNNYXRoKFxuICAgICAgICAgIGAoMzYwMCAqICR7ZmluYWxFeHByZXNzaW9uSWRaZXJvZWR9KSAvIFBFUklPRCgke2ZpbmFsRXhwcmVzc2lvbklkfSlgLFxuICAgICAgICAgIHsgW2ZpbmFsRXhwcmVzc2lvbklkXTogbWV0cmljIH0sXG4gICAgICAgICAgYCR7bGFiZWxQcmVmaXh9L2gke2xhYmVsQXBwZW5kaXh9YCxcbiAgICAgICAgICBtZXRyaWMuY29sb3IsXG4gICAgICAgICAgbWV0cmljLnBlcmlvZCxcbiAgICAgICAgICB0aGlzLmdldFJlZ2lvbihtZXRyaWMpLFxuICAgICAgICAgIHRoaXMuZ2V0QWNjb3VudChtZXRyaWMpLFxuICAgICAgICApO1xuICAgICAgY2FzZSBSYXRlQ29tcHV0YXRpb25NZXRob2QuUEVSX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTWV0cmljTWF0aChcbiAgICAgICAgICBgKDg2NDAwICogJHtmaW5hbEV4cHJlc3Npb25JZFplcm9lZH0pIC8gUEVSSU9EKCR7ZmluYWxFeHByZXNzaW9uSWR9KWAsXG4gICAgICAgICAgeyBbZmluYWxFeHByZXNzaW9uSWRdOiBtZXRyaWMgfSxcbiAgICAgICAgICBgJHtsYWJlbFByZWZpeH0vZCR7bGFiZWxBcHBlbmRpeH1gLFxuICAgICAgICAgIG1ldHJpYy5jb2xvcixcbiAgICAgICAgICBtZXRyaWMucGVyaW9kLFxuICAgICAgICAgIHRoaXMuZ2V0UmVnaW9uKG1ldHJpYyksXG4gICAgICAgICAgdGhpcy5nZXRBY2NvdW50KG1ldHJpYyksXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIG5hbWVzcGFjZSAoaWYgZGVmaW5lZCkgb3IgdGhlIGdsb2JhbCBuYW1lc3BhY2UgYXMgYSBmYWxsYmFjay5cbiAgICogSWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlIHRvIGZhbGxiYWNrIHRvIChuZWl0aGVyIHRoZSBjdXN0b20gb3IgdGhlIGRlZmF1bHQgb25lKSwgaXQgd2lsbCBmYWlsLlxuICAgKiBAcGFyYW0gdmFsdWUgY3VzdG9tIG5hbWVzcGFjZVxuICAgKi9cbiAgZ2V0TmFtZXNwYWNlV2l0aEZhbGxiYWNrKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdmFsdWUgPz8gdGhpcy5nbG9iYWxEZWZhdWx0cy5uYW1lc3BhY2U7XG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGVyZSBpcyBubyBjdXN0b20gbmFtZXNwYWNlIGRlZmluZWQuIFBsZWFzZSBzcGVjaWZ5IGl0IGluIHlvdXIgZmFjdG9yeSBkZWZhdWx0cy5cIixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0aGF0IGhlbHBzIHRvIHNhbml0aXplIHRoZSBnaXZlbiBleHByZXNzaW9uIElEIGFuZCByZW1vdmVzIGFsbCBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAqIFZhbGlkIGV4cHJlc3Npb24gSUQgcmVnZXhwIGlzIHRoZSBmb2xsb3dpbmc6IF5bYS16XVthLXpBLVowLTlfXSokXG4gICAqIEFzIHRoaXMgaXMganVzdCB0byB2YWxpZGF0ZSBhIHN1ZmZpeCBhbmQgbm90IHRoZSB3aG9sZSBJRCwgd2UgZG8gbm90IGhhdmUgdG8gdmVyaWZ5IHRoZSBmaXJzdCBsb3dlciBjYXNlIGxldHRlci5cbiAgICogQHBhcmFtIGV4cHJlc3Npb25JZCBleHByZXNzaW9uIElEIHRvIHNhbml0aXplXG4gICAqL1xuICBzYW5pdGl6ZU1ldHJpY0V4cHJlc3Npb25JZFN1ZmZpeChleHByZXNzaW9uSWQ6IHN0cmluZykge1xuICAgIHJldHVybiBleHByZXNzaW9uSWQucmVwbGFjZSgvW14wLTlhLXpfXS9naSwgXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSBnaXZlbiBhZGRpdGlvbmFsIGRpbWVuc2lvbnMgdG8gdGhlIGdpdmVuIHRhcmdldCBkaW1lbnNpb24gaGFzaC5cbiAgICogQWxsIGV4aXN0aW5nIGRpbWVuc2lvbnMgd2l0aCB0aGUgc2FtZSBrZXkgYXJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0gdGFyZ2V0IHRhcmdldCBkaW1lbnNpb24gaGFzaCB0byB1cGRhdGVcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxEaW1lbnNpb25zIGFkZGl0aW9uYWwgZGltZW5zaW9uc1xuICAgKi9cbiAgYWRkQWRkaXRpb25hbERpbWVuc2lvbnMoXG4gICAgdGFyZ2V0OiBEaW1lbnNpb25zTWFwLFxuICAgIGFkZGl0aW9uYWxEaW1lbnNpb25zOiBEaW1lbnNpb25zTWFwLFxuICApIHtcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBkaW1lbnNpb25zIGluIHRoZSBzZWFyY2ggcXVlcnlcbiAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsRGltZW5zaW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0YXJnZXRba2V5XSA9IGFkZGl0aW9uYWxEaW1lbnNpb25zW2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBkaW1lbnNpb24gaGFzaCB0aGF0IGNvbnRhaW4gYW4gdW5kZWZpbmVkIHZhbHVlLlxuICAgKiBAcGFyYW0gZGltZW5zaW9uc01hcCBkaW1lbnNpb25zIG1hcCB0byB1cGRhdGVcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhkaW1lbnNpb25zTWFwOiBEaW1lbnNpb25zTWFwKSB7XG4gICAgY29uc3QgY29weTogRGltZW5zaW9uc01hcCA9IHt9O1xuXG4gICAgT2JqZWN0LmVudHJpZXMoZGltZW5zaW9uc01hcClcbiAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiAoY29weVtrZXldID0gdmFsdWUpKTtcblxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGdldCB0aGUgYWNjb3VudCBmcm9tIHRoZSBtZXRyaWMgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUFjY291bnQoXG4gICAgbWV0cmljQWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmICghdGhpcy5zY29wZSkge1xuICAgICAgcmV0dXJuIG1ldHJpY0FjY291bnQ7XG4gICAgfVxuXG4gICAgY29uc3QgeyBhY2NvdW50IH0gPSBTdGFjay5vZih0aGlzLnNjb3BlKTtcbiAgICBpZiAobWV0cmljQWNjb3VudCAhPT0gYWNjb3VudCkge1xuICAgICAgcmV0dXJuIG1ldHJpY0FjY291bnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHByaXZhdGUgZ2V0QWNjb3VudChtZXRyaWM6IE1ldHJpY1dpdGhBbGFybVN1cHBvcnQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGxldCBtZXRyaWNBY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKG1ldHJpYyBpbnN0YW5jZW9mIE1hdGhFeHByZXNzaW9uKSB7XG4gICAgICBtZXRyaWNBY2NvdW50ID0gbWV0cmljLnNlYXJjaEFjY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldHJpY0FjY291bnQgPSBtZXRyaWMuYWNjb3VudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlQWNjb3VudChtZXRyaWNBY2NvdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBnZXQgdGhlIHJlZ2lvbiBmcm9tIHRoZSBtZXRyaWMgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZVJlZ2lvbihtZXRyaWNSZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCF0aGlzLnNjb3BlKSB7XG4gICAgICByZXR1cm4gbWV0cmljUmVnaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVnaW9uIH0gPSBTdGFjay5vZih0aGlzLnNjb3BlKTtcbiAgICBpZiAobWV0cmljUmVnaW9uICE9PSByZWdpb24pIHtcbiAgICAgIHJldHVybiBtZXRyaWNSZWdpb247XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG4gIHByaXZhdGUgZ2V0UmVnaW9uKG1ldHJpYzogTWV0cmljV2l0aEFsYXJtU3VwcG9ydCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IG1ldHJpY1JlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmIChtZXRyaWMgaW5zdGFuY2VvZiBNYXRoRXhwcmVzc2lvbikge1xuICAgICAgbWV0cmljUmVnaW9uID0gbWV0cmljLnNlYXJjaFJlZ2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0cmljUmVnaW9uID0gbWV0cmljLnJlZ2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlUmVnaW9uKG1ldHJpY1JlZ2lvbik7XG4gIH1cbn1cbiJdfQ==