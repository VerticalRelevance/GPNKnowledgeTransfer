"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePartialBatchProcessor = void 0;
const BasePartialProcessor_1 = require("./BasePartialProcessor");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
/**
 * Process batch and partially report failed items
 */
class BasePartialBatchProcessor extends BasePartialProcessor_1.BasePartialProcessor {
    /**
     * Initializes base batch processing class
     * @param eventType Whether this is SQS, DynamoDB stream, or Kinesis data stream event
     */
    constructor(eventType) {
        super();
        this.eventType = eventType;
        this.batchResponse = constants_1.DEFAULT_RESPONSE;
        this.COLLECTOR_MAPPING = {
            [constants_1.EventType.SQS]: () => this.collectSqsFailures(),
            [constants_1.EventType.KinesisDataStreams]: () => this.collectKinesisFailures(),
            [constants_1.EventType.DynamoDBStreams]: () => this.collectDynamoDBFailures(),
        };
    }
    /**
     * Report messages to be deleted in case of partial failures
     */
    clean() {
        if (!this.hasMessagesToReport()) {
            return;
        }
        if (this.entireBatchFailed()) {
            throw new errors_1.FullBatchFailureError(this.errors);
        }
        const messages = this.getMessagesToReport();
        this.batchResponse = { batchItemFailures: messages };
    }
    /**
     * Collects identifiers of failed items for a DynamoDB stream
     * @returns list of identifiers for failed items
     */
    collectDynamoDBFailures() {
        const failures = [];
        for (const msg of this.failureMessages) {
            const msgId = msg.dynamodb?.SequenceNumber;
            if (msgId) {
                failures.push({ itemIdentifier: msgId });
            }
        }
        return failures;
    }
    /**
     * Collects identifiers of failed items for a Kinesis stream
     * @returns list of identifiers for failed items
     */
    collectKinesisFailures() {
        const failures = [];
        for (const msg of this.failureMessages) {
            const msgId = msg.kinesis.sequenceNumber;
            failures.push({ itemIdentifier: msgId });
        }
        return failures;
    }
    /**
     * Collects identifiers of failed items for an SQS batch
     * @returns list of identifiers for failed items
     */
    collectSqsFailures() {
        const failures = [];
        for (const msg of this.failureMessages) {
            const msgId = msg.messageId;
            failures.push({ itemIdentifier: msgId });
        }
        return failures;
    }
    /**
     * Determines whether all records in a batch failed to process
     * @returns true if all records resulted in exception results
     */
    entireBatchFailed() {
        return this.errors.length == this.records.length;
    }
    /**
     * Collects identifiers for failed batch items
     * @returns formatted messages to use in batch deletion
     */
    getMessagesToReport() {
        return this.COLLECTOR_MAPPING[this.eventType]();
    }
    /**
     * Determines if any records failed to process
     * @returns true if any records resulted in exception
     */
    hasMessagesToReport() {
        return this.failureMessages.length != 0;
    }
    /**
     * Remove results from previous execution
     */
    prepare() {
        this.successMessages.length = 0;
        this.failureMessages.length = 0;
        this.errors.length = 0;
        this.batchResponse = constants_1.DEFAULT_RESPONSE;
    }
    /**
     * @returns Batch items that failed processing, if any
     */
    response() {
        return this.batchResponse;
    }
    toBatchType(record, eventType) {
        return constants_1.DATA_CLASS_MAPPING[eventType](record);
    }
}
exports.BasePartialBatchProcessor = BasePartialBatchProcessor;
