"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePartialProcessor = void 0;
/**
 * Abstract class for batch processors.
 */
class BasePartialProcessor {
    /**
     * Initializes base processor class
     */
    constructor() {
        this.successMessages = [];
        this.failureMessages = [];
        this.errors = [];
        this.records = [];
        this.handler = new Function();
    }
    /**
     * Keeps track of batch records that failed processing
     * @param record record that failed processing
     * @param exception exception that was thrown
     * @returns FailureResponse object with ["fail", exception, original record]
     */
    failureHandler(record, exception) {
        const entry = ['fail', exception.message, record];
        this.errors.push(exception);
        this.failureMessages.push(record);
        return entry;
    }
    /**
     * Call instance's handler for each record
     * @returns List of processed records
     */
    async process() {
        /**
         * If this is a sync processor, user should have called processSync instead,
         * so we call the method early to throw the error early thus failing fast.
         */
        if (this.constructor.name === 'BatchProcessorSync') {
            await this.processRecord(this.records[0]);
        }
        this.prepare();
        const processingPromises = this.records.map((record) => this.processRecord(record));
        const processedRecords = await Promise.all(processingPromises);
        this.clean();
        return processedRecords;
    }
    /**
     * Call instance's handler for each record
     * @returns List of processed records
     */
    processSync() {
        /**
         * If this is an async processor, user should have called process instead,
         * so we call the method early to throw the error early thus failing fast.
         */
        if (this.constructor.name === 'BatchProcessor') {
            this.processRecordSync(this.records[0]);
        }
        this.prepare();
        const processedRecords = [];
        for (const record of this.records) {
            processedRecords.push(this.processRecordSync(record));
        }
        this.clean();
        return processedRecords;
    }
    /**
     * Set class instance attributes before execution
     * @param records List of records to be processed
     * @param handler CallableFunction to process entries of "records"
     * @param options Options to be used during processing
     * @returns this object
     */
    register(records, handler, options) {
        this.records = records;
        this.handler = handler;
        if (options) {
            this.options = options;
        }
        return this;
    }
    /**
     * Keeps track of batch records that were processed successfully
     * @param record record that succeeded processing
     * @param result result from record handler
     * @returns SuccessResponse object with ["success", result, original record]
     */
    successHandler(record, result) {
        const entry = ['success', result, record];
        this.successMessages.push(record);
        return entry;
    }
}
exports.BasePartialProcessor = BasePartialProcessor;
